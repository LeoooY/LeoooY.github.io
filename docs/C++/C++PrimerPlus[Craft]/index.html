<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.62">
<title data-react-helmet="true">C++PrimerPlus[Craft] | DocsShare</title><meta data-react-helmet="true" name="docsearch:version" content="current"><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:title" content="C++PrimerPlus[Craft] | DocsShare"><meta data-react-helmet="true" name="description" content="第一章 预备知识"><meta data-react-helmet="true" property="og:description" content="第一章 预备知识"><meta data-react-helmet="true" property="og:url" content="https://leoooy.github.io//docs/C++/C++PrimerPlus[Craft]"><link data-react-helmet="true" rel="shortcut icon" href="/img/leo.png"><link data-react-helmet="true" rel="canonical" href="https://leoooy.github.io//docs/C++/C++PrimerPlus[Craft]"><link rel="stylesheet" href="/styles.fcc05d64.css">
<link rel="preload" href="/styles.da09b0aa.js" as="script">
<link rel="preload" href="/runtime~main.872dded8.js" as="script">
<link rel="preload" href="/main.2f1d5848.js" as="script">
<link rel="preload" href="/1.f45b894e.js" as="script">
<link rel="preload" href="/2.a477ba05.js" as="script">
<link rel="preload" href="/3.b78202e8.js" as="script">
<link rel="preload" href="/1be78505.89b8407a.js" as="script">
<link rel="preload" href="/171.d3ef19ea.js" as="script">
<link rel="preload" href="/935f2afb.43a6fc9a.js" as="script">
<link rel="preload" href="/17896441.30e2172e.js" as="script">
<link rel="preload" href="/6bd18adc.eb5aead5.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<nav class="navbar navbar--light navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand" href="/"><img class="navbar__logo" src="/img/leo.png" alt="My Site Logo"><strong class="navbar__title">My DocsShare</strong></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs">Notes</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/LeoooY" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><a href="https://juejin.im/user/5bebc171e51d4511a8090edb/posts" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">掘金</a><a href="https://twitter.com/LeoY233" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Twitter</a><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_2aTZ"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_BsTx">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_BsTx">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img class="navbar__logo" src="/img/leo.png" alt="My Site Logo"><strong class="navbar__title">My DocsShare</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link navbar__link--active" href="/docs">Notes</a></li><li class="menu__list-item"><a class="menu__link" href="/blog">Blog</a></li><li class="menu__list-item"><a href="https://github.com/LeoooY" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li><li class="menu__list-item"><a href="https://juejin.im/user/5bebc171e51d4511a8090edb/posts" target="_blank" rel="noopener noreferrer" class="menu__link">掘金</a></li><li class="menu__list-item"><a href="https://twitter.com/LeoY233" target="_blank" rel="noopener noreferrer" class="menu__link">Twitter</a></li></ul></div></div></div></nav><div class="main-wrapper"><div class="docPage_2gpo"><main class="docMainContainer_3EyW"><div class="container padding-vert--lg docItemWrapper_1EkI"><div class="row"><div class="col docItemCol_2ASc"><div class="docItemContainer_3QWW"><article><div><span class="badge badge--secondary">Version: Next</span></div><header><h1 class="docTitle_1Lrw">C++PrimerPlus[Craft]</h1></header><div class="markdown"><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="第一章-预备知识"></a>第一章 预备知识<a aria-hidden="true" tabindex="-1" class="hash-link" href="#第一章-预备知识" title="Direct link to heading">#</a></h2><p>C++贝尔实验室
C++标准 C++98 C++11
OOP
模板
泛型编程</p><blockquote><p>OOP提供了高级抽象，C提供了低级硬件访问</p></blockquote><p>编译</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockWrapper_2av3"><pre class="prism-code language-undefined codeBlock_2GNs" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain"># 扩展名</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">C cc cpp cxx c++ </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># cpp使用的最多</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># unix</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cc xxx.C</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># linux    </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">g++ xxx.cpp      // GNU编译器</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1Zmi">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="第二章-开始学习c"></a>第二章 开始学习C++<a aria-hidden="true" tabindex="-1" class="hash-link" href="#第二章-开始学习c" title="Direct link to heading">#</a></h2><p>HelloWorld</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockWrapper_2av3"><pre class="prism-code language-undefined codeBlock_2GNs" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">#include &lt;iostream&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">int main(){</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    using namespace std;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cout &lt;&lt; &quot;Hello Wolrd\n&quot;;    //cout是输出命令</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                                //c++中引入&lt;stdio.h&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                                //也可使用printf()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // cin.get()  用于在命令行中保持窗口打开，直到任意按键</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // cin cout 是输入输出的程序，使用时候必须引入&lt;iostream&gt;头文件</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1Zmi">Copy</button></div></div><p>函数头</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockWrapper_2av3"><pre class="prism-code language-undefined codeBlock_2GNs" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">int main()          // c++中不可省略int</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                    // 参数为空编译为 int main(void)</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1Zmi">Copy</button></div></div><p>注释</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockWrapper_2av3"><pre class="prism-code language-undefined codeBlock_2GNs" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">//</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">/*  */</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1Zmi">Copy</button></div></div><p>C++预处理器</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockWrapper_2av3"><pre class="prism-code language-undefined codeBlock_2GNs" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">#include &lt;iostream&gt;       // 将iosteam文件内容加载到此 io</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">using namespace std;</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1Zmi">Copy</button></div></div><p>名称空间 </p><div class="mdxCodeBlock_1XEh"><div class="codeBlockWrapper_2av3"><pre class="prism-code language-undefined codeBlock_2GNs" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">using namespace std</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">using std:cout</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">using std:cin</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">std:cout &lt;&lt; &quot;hello&quot;     // &lt;&lt;插入运算符</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                        // 将一个字符串插入到输出流中</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                        // &lt;&lt;插入运算符与按位左移运算符&lt;&lt;是一样的，这是运算符的重载</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                        // 编译器通过上下文确定运算符的含义</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                        // &amp;取地址运算符和按位AND运算符&amp;也是运算符的重载</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                        // * 指针、乘法</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cout &lt;&lt; endl            // 控制符endl换行，也是iostream文件中，在std命名空间内</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                        // 支持\n换行</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1Zmi">Copy</button></div></div><p>拼接输出</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockWrapper_2av3"><pre class="prism-code language-undefined codeBlock_2GNs" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">#include &lt;iostream&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">int main() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    using namespace std;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    int count;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cout &lt;&lt; &quot;How many carrots do you have?&quot; &lt;&lt; endl;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cin &gt;&gt; count;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cout &lt;&lt; &quot;Here are two More.&quot; &lt;&lt; endl;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    count = count + 2;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cout &lt;&lt; &quot;Now you Have &quot; &lt;&lt; count &lt;&lt; &quot; carrots.&quot; &lt;&lt; endl;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// &lt;&lt; 插入运算符：将信息插入到输出流 和 &gt;&gt; 抽取运算符：从输入流中抽取信息复制给变量</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 有点类似于linux中的输入输出&gt;  &lt;</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1Zmi">Copy</button></div></div><p>类</p><div class="mdxCodeBlock_1XEh"><code></code></div><p>函数</p><div class="mdxCodeBlock_1XEh"><code></code></div><p><strong>总结</strong>：
<code>C++</code>程序由一个或多个被称为函数的模块组成。程序从<code>main()</code>函数开始执行(区分大小写)。
<code>int main()</code>函数由函数头和函数体组成。函数头描述函数的返回值的类型(如果有的话)，和函数参数，函数体由<code>{}</code>花括号包裹的<code>C++</code>语句组成</p><p><code>C++</code>语句的类型：</p><ul><li>声明语句：定义使用的变量的名称和类型</li><li>赋值语句：使用赋值运算符<code>=</code>给变量赋值</li><li>消息语句：将消息发送给对象，激发某种行为 <code>cout &lt;&lt; &quot;hello&quot;</code></li><li>函数调用：执行函数。被调用函数执行完毕后，程序返回到函数调用语句之后的语句。</li><li>返回语句：<code>return</code>，返回被调用函数的只。</li></ul><p><code>类</code>是抽象出来的一个数据类型规范，描述数据的表示和操作。<code>对象</code>是一个基于类创建的实例（实体）。
<code>C++</code>提供输出输出对象<code>cin</code>和<code>cout</code>，它们分别是<code>istream</code>和<code>ostream</code>的实例，在<code>iostream</code>文件中定义。<code>&lt;&lt;</code> 插入运算符：将信息插入到输出流 和 <code>&gt;&gt;</code> 抽取运算符：从输入流中抽取信息复制给变量</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="第三章-处理数据"></a>第三章 处理数据<a aria-hidden="true" tabindex="-1" class="hash-link" href="#第三章-处理数据" title="Direct link to heading">#</a></h2><div class="mdxCodeBlock_1XEh"><div class="codeBlockWrapper_2av3"><pre class="prism-code language-undefined codeBlock_2GNs" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">short  至少16位</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">int  至少与short一样长</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">long 至少32位，且至少与int一样长</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">long long  至少32位，且至少与long一样长</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># 无符号类型, 如unsigned int 中的0-1的结果为65535</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">unsigned int a;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">unsigned long b;    </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">unsigned char s;  # 比较特殊</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">wchar_t           # 宽字符类型</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">char16_t char32_t # C++11 新增类型</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">bool</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">auto a=&#x27;xsad&#x27;     # C++11根据初始值来判断类型</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1Zmi">Copy</button></div></div><p>const</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockWrapper_2av3"><pre class="prism-code language-undefined codeBlock_2GNs" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">const type name=value   # 优先使用const定义常量，而不是#define</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1Zmi">Copy</button></div></div><p>3.4 C++算术运算符
强制类型转换</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockWrapper_2av3"><pre class="prism-code language-undefined codeBlock_2GNs" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">(typename) value</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">typename (value)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static_cast&lt;typename&gt;    # 更严格的类型转换，更安全</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1Zmi">Copy</button></div></div><p>4.7.2 指针的危险</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockWrapper_2av3"><pre class="prism-code language-undefined codeBlock_2GNs" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">long * p;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">*p=233333;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># p确实是一个指针，由于p没有初始化，它可能有任何值。不管值是什么，程序都将它解释为存储233333的地址。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># 如果p的地址碰巧为1200，计算机将把数据放在地址1200，即使这个地址和程序代码中某个变量的地址冲突。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># 这种错误可能会导致一些最隐匿、最难一跟踪的BUG</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1Zmi">Copy</button></div></div><p><strong>所以一定要在对指针使用*运算符之前，将指针初始化为一个确定的、适当的地址</strong></p><div class="mdxCodeBlock_1XEh"><div class="codeBlockWrapper_2av3"><pre class="prism-code language-undefined codeBlock_2GNs" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">int a=1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">long * p=a;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">*p=2;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">or </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">int a=1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">long * p;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">p=a;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">*p=2;</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1Zmi">Copy</button></div></div><p>4.7.4 使用<strong>new</strong>来分配内存
C语言中，是使用<code>malloc()</code>分配内存，在C++中仍然可以这样做，不过C++中还有更好的方式-<code>new</code></p><div class="mdxCodeBlock_1XEh"><div class="codeBlockWrapper_2av3"><pre class="prism-code language-undefined codeBlock_2GNs" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">int * p= new int;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># new int 告诉程序，需要适合存储int的内存。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># new运算符根据类型来确定需要多少字节的内存，然后它找到这样的内存，并返回其地址。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># 接下来，将地址赋值给pn，pn是被声明为指向int类型的指针</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># 赋值完成后，pn是地址，*pn是存储在那个地址上的值</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1Zmi">Copy</button></div></div><p><strong>为一个数据对象（可以是结构，也可以基本数据类型）获得并指定分配内存的通用格式:</strong></p><div class="mdxCodeBlock_1XEh"><div class="codeBlockWrapper_2av3"><pre class="prism-code language-undefined codeBlock_2GNs" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">typename * pointerName = new typeName;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">int *pt=new int;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">*pt=1001;</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1Zmi">Copy</button></div></div><p><strong>常规变量的内存在栈内存中，而new分配的变量在堆内存中或者自由存储区</strong>
若计算机没有足够的内存来执行new，老的实现中，new的值(地址)会为0，即空指针(null pointer),在这一章只需要知道C++提供了检测并处理内存分配失败的工具</p><p>4.7.5 使用<strong>delete</strong>释放内存</p><p>4.10 数组的替代品</p><ul><li>vector</li><li>array</li></ul><p>5.2 while循环</p><p>7.3.5 指针和const</p><blockquote><p>指针看起来总是很微妙</p><ul><li>指针指向一个常量，这样可以防止使用该指针来修改所指向的值</li><li>将指针本身声明为常量，这样可以防止改变指针指向的位置</li></ul></blockquote><p>7.10 函数指针
使用场景</p><ul><li>函数作为参数传递要传函数指针（而不是也无法直接传递函数名）</li><li></li></ul><div class="mdxCodeBlock_1XEh"><div class="codeBlockWrapper_2av3"><pre class="prism-code language-undefined codeBlock_2GNs" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">double test(int i){</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    using namespace std;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cout &lt;&lt; &quot;number is &quot; &lt;&lt; i;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1Zmi">Copy</button></div></div><p>获取函数的地址
函数名-test 就是函数的内存地址</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockWrapper_2av3"><pre class="prism-code language-undefined codeBlock_2GNs" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">process(test)           // 传递test函数的地址</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">process(test())         // 传递test函数的return值</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1Zmi">Copy</button></div></div><p>声明函数指针</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockWrapper_2av3"><pre class="prism-code language-undefined codeBlock_2GNs" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">double (*pf) (int)      // pf可以指向一个函数</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                        // 只有一个int类型的参数</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                        // 且return值类型为double</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#(*pf)是一个函数，可以调用,而pf是一个指向函数的指针。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># 通常，要声明指向特定类型的函数的指针，可以先编写函数的原型，然后用（*pf）替换函数名，这样pf就是这类函数的指针</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#注意声明中的括号</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">double (*pf) (int)      // 声明一个指针函数，return值是一个double</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">double * pf (int)      // pf()是一个函数return值是一个指向double的指针</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1Zmi">Copy</button></div></div><p>使用指针来调用函数</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockWrapper_2av3"><pre class="prism-code language-undefined codeBlock_2GNs" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">double pam(int);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">double (*pf)(int);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">pf=pam;                 // pf现在指向了pam()函数</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">double x=pam(5)         // 普通函数的调用</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">double y=(*pf)          // 指针函数的调用</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                        // 使用(*pf)时，只需将它看做函数名即可</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># 实际上C++中也可以直接使用pf()来调用指针函数</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">double z=pf(5)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># 非常棒的语法，为何pf和(*pf)等价呢？</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># 一方面，由于pf是函数指针，而*pf是函数，因此应将(*pf)()作为函数调用</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># 另一方面，由于函数名是指向该函数的指针，指向函数的指针的行为应该与此函数名相似</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># 因此pf()来调用函数也是很合理的</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># C++进行了折衷--这两种方式都是正确的（或者说是允许的，虽然它们在逻辑上是冲突的）</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># 容忍逻辑上无法自圆其说的观点正是人类思维活动的特点</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1Zmi">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="第八章-函数探幽（魔法）"></a>第八章 函数探幽（魔法）<a aria-hidden="true" tabindex="-1" class="hash-link" href="#第八章-函数探幽（魔法）" title="Direct link to heading">#</a></h2><ul><li>内联函数</li><li>引用变量</li><li>如何按引用传递参数</li><li>默认参数</li><li>函数重载</li><li>函数模板</li><li>函数模板具体化</li></ul><p>8.1 内联函数
内联函数是C++为提高程序运行速度所做的一项改进。常规函数和内联函数的区别不在与编写方式，而在于编译与运行方式。</p><p>运行程序时，操作系统将这些指令载入到计算机内存中，因此每条指令都有特定的内存地址。常规函数调用使得程序跳到另一个地址，并在函数结束时返回。</p><p>执行到函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将函数参数复制到堆栈(为此保留的内存块)，跳到标记函数起点的内存单元，执行函数代码(也许还需要将返回值放入到寄存器中)，然后跳回到地址被保存的指令处（这与阅读文章时停下来看脚注，并在阅读完脚注后返回到以前阅读的地方类似）。来回跳跃并记录跳跃位置意味着常规函数使用时，需要一定的开销。</p><p>C++内联函数则是编译器使用相应的函数代码替换函数调用。对于内联函数，程序无需跳到另一个位置处执行代码，再跳回来。因此内联函数的运行速度比常规函数稍快，但代价是需要占用更多内存。如果程序在10个不同的地方调用同一个内联函数，则程序会包含该函数代码的10个副本</p><p>应该有选择的使用内联函数。如果执行函数代码的时间比处理函数调用机制的时间长，则节省的时间将占整个过程的很小一部分。如果代码执行时间很短，则内联调用就可以节省非内联调用使用的大部分时间。另一方面，由于这个过程相当快，因此尽管节省了该过程的大部分时间，但节省的时间绝对值并不大，除非该函数经常被调用。</p><ul><li>在函数声明或定义钱加关键字<code>inline</code>
通常做法是省略原型，将整个定义放在本应该提供原型的地方</li><li>内联函数不能递归</li></ul><p>程序员请求将函数作为内联函数时，编译器并不一定会满足这种要求。它可能认为该函数过大或注意到函数调用了自己（内联函数不能递归）</p><p>内联与宏
如果C语言的宏执行了类似函数的功能，应该考虑将它们转化为C++内联函数</p><p>8.2 引用变量
创建引用变量</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockWrapper_2av3"><pre class="prism-code language-undefined codeBlock_2GNs" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">int rats;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">int &amp; ratss=rats;  // 创建rats的alais引用变量</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                  // 此时rats和ratss的地址和值都相同</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                  // 操作其中一个都会同时影响两个变量</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1Zmi">Copy</button></div></div><p>引用变量感觉和指针差不多，实际上有区别的，引用更像是const 指针</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockWrapper_2av3"><pre class="prism-code language-undefined codeBlock_2GNs" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">int rats=101；</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">int &amp; ratsX=rats;       // 创建应用</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">int * ratsY=&amp; rats;     // 创建指针</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">ratsX 和 *ratsY 都是 rats的值 ： 101，</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">&amp;ratsX 和 ratsY 都是 rats的内存地址，</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">这些变量都可以操作</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1Zmi">Copy</button></div></div><p>引用更接近const指针，必须在创建时初始化，一旦与某个变量关联起来，就将一直效忠与它</p><div class="mdxCodeBlock_1XEh"><code></code></div><p>8.3 默认参数</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockWrapper_2av3"><pre class="prism-code language-undefined codeBlock_2GNs" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">char * left (const char * str, int n=1);</span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_1Zmi">Copy</button></div></div></div></article><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Blog list page navigation"><div class="pagination-nav__item"></div><div class="pagination-nav__item pagination-nav__item--next"></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_3SO_"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#第一章-预备知识" class="table-of-contents__link">第一章 预备知识</a></li><li><a href="#第二章-开始学习c" class="table-of-contents__link">第二章 开始学习C++</a></li><li><a href="#第三章-处理数据" class="table-of-contents__link">第三章 处理数据</a></li><li><a href="#第八章-函数探幽（魔法）" class="table-of-contents__link">第八章 函数探幽（魔法）</a></li></ul></div></div></div></div></main></div></div><footer class="footer"><div class="container"><div class="text--center"><div>Copyright © 2020 LeoY233. Built with Docusaurus.</div></div></div></footer></div>
<script src="/styles.da09b0aa.js"></script>
<script src="/runtime~main.872dded8.js"></script>
<script src="/main.2f1d5848.js"></script>
<script src="/1.f45b894e.js"></script>
<script src="/2.a477ba05.js"></script>
<script src="/3.b78202e8.js"></script>
<script src="/1be78505.89b8407a.js"></script>
<script src="/171.d3ef19ea.js"></script>
<script src="/935f2afb.43a6fc9a.js"></script>
<script src="/17896441.30e2172e.js"></script>
<script src="/6bd18adc.eb5aead5.js"></script>
</body>
</html>